- 一般不用结构体+new实例化，因为占用内存过大、速度太慢，而是选取**数组模拟**方法
- 作用：常用**邻接表**，存储图和树

>此处以静态列表的数组模拟为例，适用于算法题
## 1. 存储方式
head -> 0 -> 1 -> 2 ->... 
```cpp
// head存储链表头指针，e[]存储节点（element）的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head // 头指针，指向第0个元素的位置
int e[N] // 节点的值
int ne[N] // 下一个节点的指针
int idx // 索引
```
## 2. 初始化
```cpp
// 初始化
void init()
{
    head = -1; // 头指针为空
    idx = 0; // 索引为0
}
```
## 3. 插入
> 插入的整体思路：待插入节点a指针先赋值
### 3.1 表头插入a
```cpp
// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, // 赋值 
    ne[idx] = head, // 指针赋地址
    head = idx; // 头指针重赋地址
    idx ++; // 当前索引递增
}
```
### 3.2 索引k处插入a
```cpp
void insert(int k, int a)
{
	e[idx] = x;
	ne[idx] = ne[k];
	ne[k] = idx; // 前一节点指针重赋地址
	idx ++;
}
```

## 4. 删除
### 4.1 删除第一个节点
```cpp
void remove()
{
    head = ne[head]; // 直接将头指针指向空
}
```
### 4.2 删除索引k处之后的第一个元素
```cpp
void remove(int k)
{
	ne[k] = ne[ne[k]] // 直接改变指针指向
	// 算法题不用考虑内存释放的问题
}
```
